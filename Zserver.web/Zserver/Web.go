// Package Zserver comment
// This file was generated by tars2go 1.1.4
// Generated from Web.tars
package Zserver

import (
	"fmt"

	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// Cpu struct implement
type Cpu struct {
	CpuNum int32 `json:"cpuNum"`
}

func (st *Cpu) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Cpu) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.CpuNum, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Cpu) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Cpu, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Cpu) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.CpuNum, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Cpu) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Disk struct implement
type Disk struct {
	Free  int32 `json:"free"`
	Total int32 `json:"total"`
}

func (st *Disk) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Disk) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Free, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Total, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Disk) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Disk, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Disk) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Free, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Total, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Disk) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Mem struct implement
type Mem struct {
	Free  int32 `json:"free"`
	Total int32 `json:"total"`
	Usage int32 `json:"usage"`
	Used  int32 `json:"used"`
}

func (st *Mem) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Mem) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Free, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Total, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Usage, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Used, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Mem) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Mem, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Mem) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Free, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Total, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Usage, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Used, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Mem) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Os struct implement
type Os struct {
	Arch         string `json:"arch"`
	Compiler     string `json:"compiler"`
	GoOs         string `json:"goOs"`
	Mem          int32  `json:"mem"`
	NumGoroutine int32  `json:"numGoroutine"`
	Version      string `json:"version"`
}

func (st *Os) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Os) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Arch, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Compiler, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.GoOs, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Mem, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.NumGoroutine, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Version, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Os) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Os, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Os) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Arch, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Compiler, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.GoOs, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Mem, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.NumGoroutine, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Version, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Os) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Monitor_server_res struct implement
type Monitor_server_res struct {
	Code int32 `json:"code"`
	Cpu  Cpu   `json:"cpu"`
	Disk Disk  `json:"disk"`
	Mem  Mem   `json:"mem"`
	Os   Os    `json:"os"`
}

func (st *Monitor_server_res) ResetDefault() {
	st.Cpu.ResetDefault()
	st.Disk.ResetDefault()
	st.Mem.ResetDefault()
	st.Os.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Monitor_server_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = st.Cpu.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Disk.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.Mem.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.Os.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Monitor_server_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Monitor_server_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Monitor_server_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = st.Cpu.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Disk.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.Mem.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.Os.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Monitor_server_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCaptcha_res struct implement
type GetCaptcha_res struct {
	Code int32  `json:"code"`
	Data string `json:"data"`
	Id   string `json:"id"`
	Msg  string `json:"msg"`
}

func (st *GetCaptcha_res) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *GetCaptcha_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Data, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Id, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Msg, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetCaptcha_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCaptcha_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetCaptcha_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Data, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Id, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Msg, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetCaptcha_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetMenuTreeelect_Children struct implement
type GetMenuTreeelect_Children struct {
	Id       int32                       `json:"id"`
	Label    string                      `json:"label"`
	Children []GetMenuTreeelect_Children `json:"children"`
}

func (st *GetMenuTreeelect_Children) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *GetMenuTreeelect_Children) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Label, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Children = make([]GetMenuTreeelect_Children, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Children[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetMenuTreeelect_Children) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetMenuTreeelect_Children, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetMenuTreeelect_Children) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Label, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Children)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Children {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetMenuTreeelect_Children) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetMenuTreeelect_res struct implement
type GetMenuTreeelect_res struct {
	Code int32                       `json:"code"`
	Data []GetMenuTreeelect_Children `json:"data"`
	Msg  string                      `json:"msg"`
}

func (st *GetMenuTreeelect_res) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *GetMenuTreeelect_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]GetMenuTreeelect_Children, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Data[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Msg, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetMenuTreeelect_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetMenuTreeelect_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetMenuTreeelect_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Msg, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetMenuTreeelect_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Preview_res struct implement
type Preview_res struct {
	Code int32             `json:"code"`
	Data map[string]string `json:"data"`
	Msg  string            `json:"msg"`
}

func (st *Preview_res) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Preview_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Data = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = _is.Read_string(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Data[k0] = v0
		}
	}

	err = _is.Read_string(&st.Msg, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Preview_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Preview_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Preview_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Data {

		err = _os.Write_string(k1, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(v1, 1)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Msg, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Preview_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DictData_res struct implement
type DictData_res struct {
	DictCode  int32  `json:"dictCode"`
	DictSort  int32  `json:"dictSort"`
	DictLabel string `json:"dictLabel"`
	DictValue string `json:"dictValue"`
	DictType  string `json:"dictType"`
	CssClass  string `json:"cssClass"`
	ListClass string `json:"listClass"`
	IsDefault string `json:"isDefault"`
	Status    string `json:"status"`
	Default   string `json:"default"`
	CreateBy  string `json:"createBy"`
	UpdateBy  string `json:"updateBy"`
	Remark    string `json:"remark"`
	Params    string `json:"params"`
	DataScope string `json:"dataScope"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	DeletedAt string `json:"deletedAt"`
}

func (st *DictData_res) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *DictData_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.DictCode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.DictSort, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DictLabel, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DictValue, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DictType, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CssClass, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ListClass, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.IsDefault, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Status, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Default, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreateBy, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdateBy, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Remark, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Params, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DataScope, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreatedAt, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdatedAt, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DeletedAt, 17, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DictData_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DictData_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DictData_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.DictCode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.DictSort, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DictLabel, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DictValue, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DictType, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CssClass, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ListClass, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.IsDefault, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Status, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Default, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreateBy, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdateBy, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Remark, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Params, 13)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DataScope, 14)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreatedAt, 15)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdatedAt, 16)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DeletedAt, 17)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DictData_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDBTableList_req struct implement
type GetDBTableList_req struct {
	PageSize  string `json:"pageSize"`
	PageIndex string `json:"pageIndex"`
	TableName string `json:"tableName"`
}

func (st *GetDBTableList_req) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *GetDBTableList_req) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.PageSize, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.PageIndex, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TableName, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetDBTableList_req) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDBTableList_req, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetDBTableList_req) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.PageSize, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.PageIndex, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TableName, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetDBTableList_req) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDBTableList_res struct implement
type GetDBTableList_res struct {
	Code int32               `json:"code"`
	Data GetDBTableList_Data `json:"data"`
	Msg  string              `json:"msg"`
}

func (st *GetDBTableList_res) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *GetDBTableList_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Msg, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetDBTableList_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDBTableList_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetDBTableList_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Msg, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetDBTableList_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDBTableList_List struct implement
type GetDBTableList_List struct {
	TableName      string `json:"tableName"`
	Engine         string `json:"engine"`
	TableRows      string `json:"tableRows"`
	TableCollation string `json:"tableCollation"`
	CreateTime     string `json:"createTime"`
	UpdateTime     string `json:"updateTime"`
	TableComment   string `json:"tableComment"`
}

func (st *GetDBTableList_List) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *GetDBTableList_List) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.TableName, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Engine, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TableRows, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TableCollation, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreateTime, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdateTime, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TableComment, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetDBTableList_List) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDBTableList_List, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetDBTableList_List) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.TableName, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Engine, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TableRows, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TableCollation, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreateTime, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdateTime, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TableComment, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetDBTableList_List) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDBTableList_Data struct implement
type GetDBTableList_Data struct {
	Count     int32                 `json:"count"`
	List      []GetDBTableList_List `json:"list"`
	PageIndex int32                 `json:"pageIndex"`
	PageSize  int32                 `json:"pageSize"`
}

func (st *GetDBTableList_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *GetDBTableList_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Count, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.List = make([]GetDBTableList_List, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.List[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.PageIndex, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.PageSize, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetDBTableList_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDBTableList_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetDBTableList_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Count, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.List)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.List {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.PageIndex, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.PageSize, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetDBTableList_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDBColumnList_req struct implement
type GetDBColumnList_req struct {
	PageSize  string `json:"pageSize"`
	PageIndex string `json:"pageIndex"`
	TableName string `json:"tableName"`
}

func (st *GetDBColumnList_req) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *GetDBColumnList_req) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.PageSize, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.PageIndex, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TableName, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetDBColumnList_req) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDBColumnList_req, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetDBColumnList_req) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.PageSize, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.PageIndex, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TableName, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetDBColumnList_req) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDBColumnList_res struct implement
type GetDBColumnList_res struct {
	Code int32                `json:"code"`
	Data GetDBColumnList_Data `json:"data"`
	Msg  string               `json:"msg"`
}

func (st *GetDBColumnList_res) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *GetDBColumnList_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Msg, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetDBColumnList_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDBColumnList_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetDBColumnList_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Msg, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetDBColumnList_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDBColumnList_List struct implement
type GetDBColumnList_List struct {
	TableSchema            string `json:"tableSchema"`
	TableName              string `json:"tableName"`
	ColumnName             string `json:"columnName"`
	ColumnDefault          string `json:"columnDefault"`
	IsNullable             string `json:"isNullable"`
	DataType               string `json:"dataType"`
	CharacterMaximumLength string `json:"characterMaximumLength"`
	CharacterSetName       string `json:"characterSetName"`
	ColumnType             string `json:"columnType"`
	ColumnKey              string `json:"columnKey"`
	Extra                  string `json:"extra"`
	ColumnComment          string `json:"columnComment"`
}

func (st *GetDBColumnList_List) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *GetDBColumnList_List) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.TableSchema, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TableName, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ColumnName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ColumnDefault, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.IsNullable, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DataType, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CharacterMaximumLength, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CharacterSetName, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ColumnType, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ColumnKey, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Extra, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ColumnComment, 11, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetDBColumnList_List) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDBColumnList_List, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetDBColumnList_List) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.TableSchema, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TableName, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ColumnName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ColumnDefault, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.IsNullable, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DataType, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CharacterMaximumLength, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CharacterSetName, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ColumnType, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ColumnKey, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Extra, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ColumnComment, 11)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetDBColumnList_List) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDBColumnList_Data struct implement
type GetDBColumnList_Data struct {
	Count     int32                  `json:"count"`
	List      []GetDBColumnList_List `json:"list"`
	PageIndex int32                  `json:"pageIndex"`
	PageSize  int32                  `json:"pageSize"`
}

func (st *GetDBColumnList_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *GetDBColumnList_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Count, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.List = make([]GetDBColumnList_List, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.List[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.PageIndex, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.PageSize, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetDBColumnList_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDBColumnList_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetDBColumnList_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Count, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.List)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.List {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.PageIndex, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.PageSize, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetDBColumnList_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Table_req struct implement
type Table_req struct {
	PageSize     string `json:"pageSize"`
	PageIndex    string `json:"pageIndex"`
	TableName    string `json:"tableName"`
	TableComment string `json:"tableComment"`
}

func (st *Table_req) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Table_req) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.PageSize, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.PageIndex, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TableName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TableComment, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Table_req) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Table_req, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Table_req) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.PageSize, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.PageIndex, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TableName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TableComment, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Table_req) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SysTables_Data struct implement
type SysTables_Data struct {
	Count     int32            `json:"count"`
	Data      []SysTables_List `json:"data"`
	PageIndex int32            `json:"pageIndex"`
	PageSize  int32            `json:"pageSize"`
}

func (st *SysTables_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SysTables_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Count, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]SysTables_List, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Data[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.PageIndex, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.PageSize, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysTables_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysTables_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysTables_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Count, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.PageIndex, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.PageSize, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysTables_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SysTables_res struct implement
type SysTables_res struct {
	Code int32          `json:"code"`
	Data SysTables_Data `json:"data"`
	Msg  string         `json:"msg"`
}

func (st *SysTables_res) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SysTables_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Msg, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysTables_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysTables_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysTables_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Msg, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysTables_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SysTables_one_res struct implement
type SysTables_one_res struct {
	Code int32          `json:"code"`
	Data SysTables_List `json:"data"`
	Msg  string         `json:"msg"`
}

func (st *SysTables_one_res) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SysTables_one_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Msg, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysTables_one_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysTables_one_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysTables_one_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Msg, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysTables_one_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SysTables_List struct implement
type SysTables_List struct {
	TableId             int32            `json:"tableId"`
	TableName           string           `json:"tableName"`
	TableComment        string           `json:"tableComment"`
	ClassName           string           `json:"className"`
	TplCategory         string           `json:"tplCategory"`
	PackageName         string           `json:"packageName"`
	ModuleName          string           `json:"moduleName"`
	BusinessName        string           `json:"businessName"`
	FunctionName        string           `json:"functionName"`
	FunctionAuthor      string           `json:"functionAuthor"`
	PkColumn            string           `json:"pkColumn"`
	PkGoField           string           `json:"pkGoField"`
	PkJsonField         string           `json:"pkJsonField"`
	Options             string           `json:"options"`
	TreeCode            string           `json:"treeCode"`
	TreeParentCode      string           `json:"treeParentCode"`
	TreeName            string           `json:"treeName"`
	Tree                bool             `json:"tree"`
	Crud                bool             `json:"crud"`
	Remark              string           `json:"remark"`
	IsLogicalDelete     string           `json:"isLogicalDelete"`
	LogicalDelete       bool             `json:"logicalDelete"`
	LogicalDeleteColumn string           `json:"logicalDeleteColumn"`
	CreateBy            string           `json:"createBy"`
	UpdateBy            string           `json:"updateBy"`
	DataScope           string           `json:"dataScope"`
	Params              Params           `json:"params"`
	Columns             []SysColumns_res `json:"columns"`
	CreatedAt           string           `json:"createdAt"`
	UpdatedAt           string           `json:"updatedAt"`
	DeletedAt           string           `json:"deletedAt"`
}

func (st *SysTables_List) ResetDefault() {
	st.Params.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SysTables_List) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.TableId, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TableName, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TableComment, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ClassName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TplCategory, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.PackageName, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ModuleName, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.BusinessName, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.FunctionName, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.FunctionAuthor, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.PkColumn, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.PkGoField, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.PkJsonField, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Options, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TreeCode, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TreeParentCode, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TreeName, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Tree, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Crud, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Remark, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.IsLogicalDelete, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.LogicalDelete, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.LogicalDeleteColumn, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreateBy, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdateBy, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DataScope, 25, false)
	if err != nil {
		return err
	}

	err = st.Params.ReadBlock(_is, 26, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(27, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Columns = make([]SysColumns_res, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Columns[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.CreatedAt, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdatedAt, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DeletedAt, 30, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysTables_List) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysTables_List, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysTables_List) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.TableId, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TableName, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TableComment, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ClassName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TplCategory, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.PackageName, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ModuleName, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.BusinessName, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.FunctionName, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.FunctionAuthor, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.PkColumn, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.PkGoField, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.PkJsonField, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Options, 13)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TreeCode, 14)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TreeParentCode, 15)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TreeName, 16)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Tree, 17)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Crud, 18)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Remark, 19)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.IsLogicalDelete, 20)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.LogicalDelete, 21)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.LogicalDeleteColumn, 22)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreateBy, 23)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdateBy, 24)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DataScope, 25)
	if err != nil {
		return err
	}

	err = st.Params.WriteBlock(_os, 26)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 27)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Columns)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Columns {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.CreatedAt, 28)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdatedAt, 29)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DeletedAt, 30)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysTables_List) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Params struct implement
type Params struct {
	TreeCode       string `json:"treeCode"`
	TreeParentCode string `json:"treeParentCode"`
	TreeName       string `json:"treeName"`
}

func (st *Params) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Params) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.TreeCode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TreeParentCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.TreeName, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Params) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Params, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Params) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.TreeCode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TreeParentCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.TreeName, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Params) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SysColumns_res struct implement
type SysColumns_res struct {
	ColumnId      int32  `json:"columnId"`
	TableId       int32  `json:"tableId"`
	ColumnName    string `json:"columnName"`
	ColumnComment string `json:"columnComment"`
	ColumnType    string `json:"columnType"`
	GoType        string `json:"goType"`
	GoField       string `json:"goField"`
	JsonField     string `json:"jsonField"`
	IsPk          string `json:"isPk"`
	IsIncrement   string `json:"isIncrement"`
	IsRequired    string `json:"isRequired"`
	IsInsert      string `json:"isInsert"`
	IsEdit        string `json:"isEdit"`
	IsList        string `json:"isList"`
	IsQuery       string `json:"isQuery"`
	QueryType     string `json:"queryType"`
	HtmlType      string `json:"htmlType"`
	DictType      string `json:"dictType"`
	Sort          int32  `json:"sort"`
	List          string `json:"list"`
	Pk            bool   `json:"pk"`
	Required      bool   `json:"required"`
	SuperColumn   bool   `json:"superColumn"`
	UsableColumn  bool   `json:"usableColumn"`
	Increment     bool   `json:"increment"`
	Insert        bool   `json:"insert"`
	Edit          bool   `json:"edit"`
	Query         bool   `json:"query"`
	Remark        string `json:"remark"`
	CreateBy      string `json:"createBy"`
	UpdateBy      string `json:"updateBy"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
	DeletedAt     string `json:"deletedAt"`
}

func (st *SysColumns_res) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SysColumns_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.ColumnId, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.TableId, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ColumnName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ColumnComment, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ColumnType, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.GoType, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.GoField, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.JsonField, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.IsPk, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.IsIncrement, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.IsRequired, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.IsInsert, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.IsEdit, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.IsList, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.IsQuery, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.QueryType, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.HtmlType, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DictType, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Sort, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.List, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Pk, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Required, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.SuperColumn, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.UsableColumn, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Increment, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Insert, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Edit, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Query, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Remark, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreateBy, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdateBy, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreatedAt, 31, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdatedAt, 32, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DeletedAt, 33, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysColumns_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysColumns_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysColumns_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.ColumnId, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.TableId, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ColumnName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ColumnComment, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ColumnType, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.GoType, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.GoField, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.JsonField, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.IsPk, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.IsIncrement, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.IsRequired, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.IsInsert, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.IsEdit, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.IsList, 13)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.IsQuery, 14)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.QueryType, 15)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.HtmlType, 16)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DictType, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Sort, 18)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.List, 19)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Pk, 20)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Required, 21)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.SuperColumn, 22)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.UsableColumn, 23)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Increment, 24)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Insert, 25)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Edit, 26)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Query, 27)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Remark, 28)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreateBy, 29)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdateBy, 30)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreatedAt, 31)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdatedAt, 32)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DeletedAt, 33)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysColumns_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InsertSysTable_req struct implement
type InsertSysTable_req struct {
	Tables string `json:"tables"`
}

func (st *InsertSysTable_req) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InsertSysTable_req) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Tables, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InsertSysTable_req) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InsertSysTable_req, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InsertSysTable_req) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Tables, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InsertSysTable_req) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Response_res struct implement
type Response_res struct {
	Code int32  `json:"code"`
	Data string `json:"data"`
	Msg  string `json:"msg"`
}

func (st *Response_res) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Response_res) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Data, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Msg, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Response_res) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Response_res, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Response_res) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Data, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Msg, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Response_res) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LoginLog struct implement
type LoginLog struct {
	InfoId        int32  `json:"infoId"`
	Username      string `json:"username"`
	Status        string `json:"status"`
	Ipaddr        string `json:"ipaddr"`
	LoginLocation string `json:"loginLocation"`
	Browser       string `json:"browser"`
	Os            string `json:"os"`
	Platform      string `json:"platform"`
	LoginTime     string `json:"loginTime"`
	CreateBy      string `json:"createBy"`
	UpdateBy      string `json:"updateBy"`
	DataScope     string `json:"dataScope"`
	Params        string `json:"params"`
	Remark        string `json:"remark"`
	Msg           string `json:"msg"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
	DeletedAt     string `json:"deletedAt"`
}

func (st *LoginLog) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *LoginLog) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.InfoId, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Username, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Status, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Ipaddr, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.LoginLocation, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Browser, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Os, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Platform, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.LoginTime, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreateBy, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdateBy, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DataScope, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Params, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Remark, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Msg, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreatedAt, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdatedAt, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DeletedAt, 17, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LoginLog) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LoginLog, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LoginLog) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.InfoId, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Username, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Status, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Ipaddr, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.LoginLocation, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Browser, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Os, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Platform, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.LoginTime, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreateBy, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdateBy, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DataScope, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Params, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Remark, 13)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Msg, 14)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreatedAt, 15)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdatedAt, 16)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DeletedAt, 17)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LoginLog) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LoginLog_List struct implement
type LoginLog_List struct {
	LoginLogList []LoginLog `json:"loginLogList"`
	Count        int32      `json:"count"`
}

func (st *LoginLog_List) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *LoginLog_List) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.LoginLogList = make([]LoginLog, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.LoginLogList[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Count, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LoginLog_List) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LoginLog_List, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LoginLog_List) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.LoginLogList)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.LoginLogList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Count, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LoginLog_List) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SysConfig struct implement
type SysConfig struct {
	ConfigId    int32  `json:"configId"`
	ConfigName  string `json:"configName"`
	ConfigKey   string `json:"configKey"`
	ConfigValue string `json:"configValue"`
	ConfigType  string `json:"configType"`
	Remark      string `json:"remark"`
	CreateBy    string `json:"createBy"`
	UpdateBy    string `json:"updateBy"`
	DataScope   string `json:"dataScope"`
	Params      string `json:"params"`
	CreatedAt   string `json:"createdAt"`
	UpdatedAt   string `json:"updatedAt"`
	DeletedAt   string `json:"deletedAt"`
}

func (st *SysConfig) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SysConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.ConfigId, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ConfigName, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ConfigKey, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ConfigValue, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ConfigType, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Remark, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreateBy, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdateBy, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DataScope, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Params, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreatedAt, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdatedAt, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DeletedAt, 12, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.ConfigId, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ConfigName, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ConfigKey, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ConfigValue, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ConfigType, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Remark, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreateBy, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdateBy, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DataScope, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Params, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreatedAt, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdatedAt, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DeletedAt, 12)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SysConfig_List struct implement
type SysConfig_List struct {
	SysConfigList []SysConfig `json:"sysConfigList"`
	Count         int32       `json:"count"`
}

func (st *SysConfig_List) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SysConfig_List) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.SysConfigList = make([]SysConfig, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.SysConfigList[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Count, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysConfig_List) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysConfig_List, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysConfig_List) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.SysConfigList)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.SysConfigList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Count, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysConfig_List) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SysUser struct implement
type SysUser struct {
	UserId    int32  `json:"userId"`
	NickName  string `json:"nickName"`
	Phone     string `json:"phone"`
	RoleId    int32  `json:"roleId"`
	Salt      string `json:"salt"`
	Avatar    string `json:"avatar"`
	Sex       string `json:"sex"`
	Email     string `json:"email"`
	DeptId    int32  `json:"deptId"`
	PostId    int32  `json:"postId"`
	CreateBy  string `json:"createBy"`
	UpdateBy  string `json:"updateBy"`
	Remark    string `json:"remark"`
	Status    string `json:"status"`
	DataScope string `json:"dataScope"`
	Params    string `json:"params"`
	Username  string `json:"username"`
	Password  string `json:"password"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	DeletedAt string `json:"deletedAt"`
	Role_name string `json:"role_name"`
	DeptName  string `json:"deptName"`
}

func (st *SysUser) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SysUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.UserId, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.NickName, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.RoleId, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Salt, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Avatar, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Sex, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Email, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.DeptId, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.PostId, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreateBy, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdateBy, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Remark, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Status, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DataScope, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Params, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Username, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Password, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.CreatedAt, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UpdatedAt, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DeletedAt, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Role_name, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DeptName, 22, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.UserId, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.NickName, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.RoleId, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Salt, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Avatar, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Sex, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Email, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.DeptId, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.PostId, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreateBy, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdateBy, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Remark, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Status, 13)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DataScope, 14)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Params, 15)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Username, 16)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Password, 17)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.CreatedAt, 18)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UpdatedAt, 19)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DeletedAt, 20)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Role_name, 21)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DeptName, 22)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SysUser_List struct implement
type SysUser_List struct {
	SysUserList []SysUser `json:"sysUserList"`
	Count       int32     `json:"count"`
}

func (st *SysUser_List) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SysUser_List) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.SysUserList = make([]SysUser, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.SysUserList[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Count, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysUser_List) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysUser_List, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysUser_List) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.SysUserList)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.SysUserList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Count, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysUser_List) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SysUserPwd struct implement
type SysUserPwd struct {
	OldPassword string `json:"oldPassword"`
	NewPassword string `json:"newPassword"`
}

func (st *SysUserPwd) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SysUserPwd) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.OldPassword, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.NewPassword, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysUserPwd) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysUserPwd, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysUserPwd) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.OldPassword, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.NewPassword, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysUserPwd) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}
